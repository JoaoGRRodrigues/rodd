'''
Created on Jan 11, 2012

@author: gaubert
'''

def euler_problem_1():
    """
       If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

       Find the sum of all the multiples of 3 or 5 below 1000.
    """
    
    result = 0
    
    for num in xrange(0,1000):
        if (num % 3) == 0 or (num % 5) == 0:
            print("add %d\n" % (num))
            result += num
    
    print("Euler Problem 1 result = %d\n" % (result))
    
def euler_problem_2():
    """
       Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

             1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

       By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    """
    
    fib = []
    
    f_n_1 = 1
    f_n_2 = 2
    
    sum = f_n_2
    
    print("fib[%d] = %d\n" % (1, f_n_1 ))
    print("fib[%d] = %d\n" % (2, f_n_2 ))
    
    for i in xrange(3, 4000000):
        f_res = f_n_2 + f_n_1
        
        if f_res > 4000000:
            break  
        
        #if i % 100000 == 0:
        #    print("fib[%d] = %d\n" % (i, f_res))
        
        #can be divided by 2 so even
        if f_res % 2 == 0:
            sum += f_res
            print("Sum[%d] = %s\n" % (i , sum) )
        
        
        #permute n-1 and n-2
        f_n_1 = f_n_2
        f_n_2 = f_res
    
    print("Sum = %s\n" % (sum))

def euler_problem_3():
    """
    The prime factors of 13195 are 5, 7, 13 and 29.

    What is the largest prime factor of the number 600851475143 (call it n) ?
    
    the largest prime number is n-1
    find the list of prime numbers from 2 to n
    When a prime factor is found divide the result by it (next prime factor cannot be bigger)
     
    """
    prime_factor = [2,3,5,7,11,13,17,19]
    
    largest_found = 1
    prime_factored = 1
    
    i = 20
    number = 600851475143
    while i <= number:
        
        not_prime = False
        for j in prime_factor:
            if i % j == 0:
                not_prime = True
                #print("%d is not prime (can be divided by %d)" %(i, j))
                break
            
        if not not_prime:
            prime_factor.append(i)
            
            if number % i == 0:
                print("new largest prime = %d\n" % (i))
                largest_found = i 
                number /= i
        
        i += 1
        
    
    print("prime_factor list %s\n" % (prime_factor))
    
    
def euler_problem_4():
    """
    A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 99.

    Find the largest palindrome made from the product of two 3-digit numbers.
    
    Palindrome cannot be bigger than 999x999 (BxC)
    if BxC is not a palindrome
       try B x (C-1), B x (C-2)
    
    if cannot find palindrome (999-1)x(999-1)
    
    Solution:
    The palindrome can be written as:

    abccba
    
    Which then simpifies to:
    
    100000a + 10000b + 1000c + 100c + 10b + a
    
    And then:
    
    100001a + 10010b + 1100c
    
    Factoring out 11, you get:
    
    11(9091a + 910b + 100c)
    
    So the palindrome must be divisible by 11.  Seeing as 11 is prime, at least one of the numbers must be divisible by 11.  So brute force in Python, only with less numbers to be checked:
    
    Python
    Hide Code
    def c():
        max = maxI = maxJ = 0
        i = 999
        j = 990
        while (i > 100):
            j = 990
            while (j > 100):
                product = i * j
                if (product > max):
                    productString = str(product)
                    if (productString == productString[::-1]):
                        max = product
                        maxI = i
                        maxJ = j
                j -= 11
            i -= 1
        return max, maxI, maxJ
    
    
    Returns an answer in 0.016 secs.
     
    """ 
    
    def is_palindrome(nb):
        """
             n = num;
             rev = 0;
             while (num > 0)
             {
                  dig = num % 10;
                  rev = rev * 10 + dig;
                  num = num / 10;
             }
        """
        s = str(nb)
        return s == s[::-1]
        
    B = 999
    C = 999
    
    res = -1
    palindrome = -1
    
    while B >= 100:
        while C >= 100:
            res = B*C
            if is_palindrome(res):
                if res > palindrome:
                    palindrome = res
                    print("New highest B(%s)*C(%s) = %s\n" % (B, C, palindrome))

            C -= 1
    
        B -= 1
        C = 999
        
    print("largest palindrome is %s\n" % (palindrome))
    
def euler_problem5():
    """
       2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

       What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    """

    

def generate_random_nb_between1_to_5():
    """
       Generate a random number between 1 and 5
    """
    
    import time
    import math
    
    frac, int_p = math.modf(time.time())
    print("sleep time = %s\n" % (frac))
    time.sleep(frac)
    ran_nb = time.time()
    print("random number = %s\n" % (ran_nb))
    ran_nb = round( ran_nb * (ran_nb - math.floor(ran_nb)) )
    print("random number = %s\n" % (ran_nb))
    
    if ran_nb % 5 == 0:
        #multiple of 5 so return 5
        return 5
    elif ran_nb % 4 == 0:
        #multiple of 4 so return 4
        return 4
    elif ran_nb % 3 == 0:
        #multiple of 3 so return 3
        return 3
    elif ran_nb % 2 == 0:
        #multiple of 2 so return 2
        return 2
    else:
        return 1
    
def generate_random_nb_between1_to_7():
    """
       Generate a random number between 1 and 7
    """
    
    import time
    import math
    
    frac, int_p = math.modf(time.time())
    print("sleep time = %s\n" % (frac))
    time.sleep(frac)
    ran_nb = time.time()
    print("random number = %s\n" % (ran_nb))
    ran_nb = round( ran_nb * (ran_nb - math.floor(ran_nb)) )
    print("random number = %s\n" % (ran_nb))
    
    if ran_nb % 7 == 0:
        return 7
    elif ran_nb % 6 == 0:
        return 6
    elif ran_nb % 5 == 0:
        #multiple of 5 so return 5
        return 5
    elif ran_nb % 4 == 0:
        #multiple of 4 so return 4
        return 4
    elif ran_nb % 3 == 0:
        #multiple of 3 so return 3
        return 3
    elif ran_nb % 2 == 0:
        #multiple of 2 so return 2
        return 2
    else:
        return 1
        
    

if __name__ == '__main__':
    #euler_problem_1()
    
    euler_problem_4()
    
    #for i in range(0,20):
    #    print("Random number = %s\n" % (generate_random_nb_between1_to_7() ) )